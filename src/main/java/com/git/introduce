git ----文档学习
集中式与分布式
    Git 属于分布式版本控制系统,而svn属于集中式。 对比图如图2所示
    集中式VS分布式
        1.集中式版本控制只有中心服务器拥有一份代码，而分布式版本控制每个人的电脑上就有一份完整的代码。
        2.集中式版本控制需要连网才能工作，如果网速过慢，那么提交一个文件会慢的无法让人忍受。而分布式版本控制不需要连网就能工作。
        3.集中式版本控制有安全性问题，当中心服务器挂了所有人都没办法工作了。
        4.分布式版本控制新建分支、合并分支操作速度非常快，而集中式版本控制新建一个分支相当于复制一份完整代码。

    中心服务器
        中心服务器用来交换每个用户的修改，没有中心服务器也能工作，但是中心服务器能够 24 小时保持开机状态，这样就能更方便的交换修改。
        Github 就是一个中心服务器。

    工作流
        新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录 .git，它属于 Git 的版本库。
        Git 的版本库有一个称为 Stage 的暂存区以及最后的 History 版本库，History 存储所有分支信息，使用一个 HEAD 指针指向当前分支。如图三所示。

        git add files 把文件的修改添加到暂存区
        git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了
        git reset -- files 使用当前分支上的修改覆盖暂存区，用来撤销最后一次 git add files
        git checkout -- files 使用暂存区的修改覆盖工作目录，用来撤销本地修改
        关系如图4

        可以跳过暂存区域直接从分支中取出修改，或者直接提交修改到分支中。
        git commit -a 直接把所有文件的修改添加到暂存区然后执行提交
        git checkout HEAD -- files 取出最后一次修改，可以用来进行回滚操作

    实现分支：
        使用指针将每个连接成一条时间线，Head指针指向当前分支指针；
        新建分支是新建一个指针指向时间线的最后一个节点，并让HEAD指针指向新的分支，表示新分支成为当前分支。
        每次提交只会让当前分支指针向前移动，而其它分支指针不会移动。
        合并分支也只需要改变指针即可。
    冲突
        当两个分支都对同一个文件的同一行进行了修改，在分支合并时就会产生冲突。
        Git 会使用 <<<<<<< ，======= ，>>>>>>> 标记出不同分支的内容，只需要把不同分支中冲突部分修改成一样就能解决冲突。
        <<<<<<< HEAD
        Creating a new branch is quick & simple.
        =======
        Creating a new branch is quick AND simple.
        >>>>>>> feature1
    Fast forward
        "快进式合并"（fast-farward merge），
        会直接将 master 分支指向合并的分支，这种模式下进行分支合并会丢失分支信息，也就不能在分支历史上看出分支信息。
        可以在合并时加上 --no-ff 参数来禁用 Fast forward 模式，并且加上 -m 参数让合并时产生一个新的 commit。
        git merge --no-ff -m "merge with no-ff" dev
    储藏（Stashing）
    




